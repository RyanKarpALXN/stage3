"""
    This file is part of STaGE - a wrapper for generating
    GROMACS topology files.

    Written by Magnus Lundborg
    Copyright (c) 2013-2014, The GROMACS development team.
    Check out http://www.gromacs.org for more information.

    This code is released under GNU LGPL V3.0 and may be released under
    a later version of the LGPL.
"""

# Class for molecules

import math
try:
    import numpy as np
    numpyFound = True
except ImportError:
    numpyFound = False


ATOMMASSES = {'H': 1.0,
               'Li': 6.9, 'C': 12.0, 'N': 14.0, 'O': 16.0, 'F': 19.0,
               'Na': 23.0, 'Mg': 24.3, 'Al': 27.0, 'Si': 28.1, 'P': 31.0, 'S': 32.1, 'Cl': 35.5,
               'K': 39.1, 'Ca': 40.1, 'Fe': 55.8, 'Cu': 63.5, 'Zn': 65.4, 'Se': 79.0, 'Br': 79.9,
               'I': 126.9}

def flatten(input):

    output = []
    stack = []
    stack.extend(reversed(input))

    while stack:
        top = stack.pop()
        if isinstance(top, (list, tuple)):
            stack.extend(reversed(top))
        else:
            output.append(top)

    return output


class MolSystem:

    def __init__(self, name = None, molecules = None, comments = None):

        self.name = name
        self.molecules = molecules or []
        self.comments = comments or []
        self.time     = 0.0  # .gro files can have a time stamp even if the first frame is only read
        self.boxVector = [0, 0, 0, 0, 0, 0]
        self.residueOffset = 0

    def getMolecules(self):

        return self.molecules

    def writePdb(self, outFile):

        for comment in self.comments:
            outFile.write('REMARK %s\n' % comment)
        if self.name:
            outFile.write('TITLE\t%s\n' % self.name)
        for molecule in self.molecules:
            for atom in molecule.atoms:
                outFile.write('%s\n' % atom.pdbOutput())
        # Not writing CONNECT yet
        outFile.write('END\n')

    def writeMol2(self, outFile):

        for molecule in self.molecules:
            molecule.writeMol2(outFile)

    def writeGro(self, outFile):

        if not self.comments:
            self.comments = ['Generated by STaGE']
        outFile.write('%s, %f\n' % (self.comments[0].rstrip(), self.time))

        nAtoms = 0
        for molecule in self.molecules:
            nAtoms += len(molecule.atoms)
        outFile.write('%5d\n' % nAtoms)
        for molecule in self.molecules:
            for atom in molecule.atoms:
                outFile.write('%s\n' % atom.groOutput())
        outFile.write('%f %f %f\n' % (self.boxVector[0],
                                      self.boxVector[1],
                                      self.boxVector[2]))

    def writeAmsol(self, outFile, keywords):
        outFile.write('%s\n' % keywords)
        for molecule in self.molecules:
            outFile.write('%s\n\n' % molecule.name)
            for atom in molecule.atoms:
                outFile.write('%s\n' % atom.amsolOutput())

    def findMolecule(self, name):

        for molecule in self.molecules:
            if molecule.name == name:
                return molecule
        return None

    def readPdbFile(self, filename):

        with open(filename) as f:
            lines = f.readlines()

        self.readPdb(lines)

    def readMol2File(self, filename):

        with open(filename) as f:
            lines = f.readlines()

        self.readMol2(lines)

    def readGroFile(self, filename):

        with open(filename) as f:
            lines = f.readlines()

        self.readGro(lines)

    def readPdb(self, lines):

        self.readPdbAtoms(lines)
        self.readPdbBonds(lines)

    def readMol2(self, lines):

        nLines = len(lines)

        i = 0
        while i < nLines:
            if lines[i].startswith('@<TRIPOS>MOLECULE'):
                i += 1
                molName = lines[i].strip()

                if molName == '*****':
                    molName = 'LIG'

                mole = self.findMolecule(molName)

                if not mole:
                    mole = Molecule(molName, self)
                    self.molecules.append(mole)

                i += 2
                mole.molType = lines[i].strip().upper()
                i += 1
                mole.chargeType = lines[i].strip().upper()

            end = self.readMol2Atoms(mole, lines, i)
            if end:
                i = end
            end = self.readMol2Bonds(mole, lines, i)
            if end:
                i = end

            if i < nLines and not lines[i].startswith('@<TRIPOS>MOLECULE'):
                i += 1

    def readGro(self, lines):

        line = lines[0]
        parts = line.split(',')
        self.comments = [parts[0]]
        try:
            self.time = float(parts[1])
        except Exception:
            pass

        if self.molecules:
            mole = self.molecules[0]
        else:
            mole = Molecule('', self)
            self.molecules.append(mole)

        nAtoms = int(lines[1])

        for i in range(nAtoms):
            line = lines[i+2]
            resnr = int(line[:5].strip())
            rname = line[5:10].strip()
            aname = line[10:15].strip()
            anr = int(line[15:20].strip())
            coordX = float(line[20:28].strip()) * 10
            coordY = float(line[28:36].strip()) * 10
            coordZ = float(line[36:44].strip()) * 10
            n = min(len(line), 68)
            if n > 60:
                velX = float(line[44:52].strip()) * 10
                velY = float(line[52:60].strip()) * 10
                velZ = float(line[60:n].strip()) * 10
            else:
                velX = None
                velY = None
                velZ = None

            res = mole.findResidue(rname, resnr)
            if not res:
                res = Residue(rname, mole, resnr)
                mole.residues.append(res)

            atom = Atom(res, anr, aname)

            atom.setCoords(coordX, coordY, coordZ)
            atom.setVels(velX, velY, velZ)

            res.atoms.append(atom)
            mole.atoms.append(atom)

        line = lines[nAtoms + 2]
        parts = line.split()
        if len(parts) == 3:
            for i in range(3):
                self.boxVector[i] = float(parts[i])

    def readPdbAtoms(self, lines, removeHydrogens=False):

        for line in lines:
            if not line.startswith('ATOM') and not line.startswith('HETATM'):
                continue
            chain = line[21]
            segment = line[72:76].strip()
            if len(segment) <= 0 and len(chain) > 0:
                segment = chain

            mole = self.findMolecule(segment)
            if mole == None:
                mole = Molecule(segment, self)
                self.molecules.append(mole)

            atomClass = line[0:6].strip()
            atomNr = int(line[6:11].strip())
            atomName = line[12:16].strip()
            if removeHydrogens and atomName[0] == 'H' or \
                 (atomName[0].isdigit() and atomName[1] == 'H'):
                continue

            altLoc = line[16].strip()
            resName = line[17:20].strip()
            resNr = int(line[22:26].strip()) + self.residueOffset
            insertCode = line[26].strip()
            atomX = float(line[30:38].strip())
            atomY = float(line[38:46].strip())
            atomZ = float(line[46:54].strip())
            occupancy = float(line[54:60].strip())
            tempFactor = float(line[60:66].strip())
            element = line[76:78].strip()
            try:
                charge = float(line[78:80].strip())
            except ValueError as e:
                charge = None
            res = mole.findResidue(resName, resNr)
            if not res:
                res = Residue(resName, mole, resNr, chain = chain)
                mole.residues.append(res)
            # If this atom already exists in this residue it is probably a
            # different chain. Create a new residue.
            elif res.findAtom(atomName) and resName != 'LIG':
                res = Residue(resName, mole, resNr, chain = chain)
                mole.residues.append(res)

            atom = Atom(res, atomNr, atomName, element)

            atom.setAtomClass(atomClass)
            atom.setCharge(charge)
            atom.setCoords(atomX, atomY, atomZ)
            atom.setOccupancy(occupancy)
            atom.setTempFactor(tempFactor)
            atom.setSegment(segment)
            atom.setAlternateLocation(altLoc)
            atom.setInsertCode(insertCode)

            res.atoms.append(atom)
            mole.atoms.append(atom)

    def readPdbBonds(self, lines):

        hydrogenBondedAtoms = []
        saltBridgedAtoms = []

        for line in lines:
            bondAtoms = []
            if not line.startswith('CONECT'):
                continue

            try:
                atomNr = int(line[6:11].strip())
                atom = self.findAtomNumber(atomNr)
            except Exception:
                continue

            for i in [11, 16, 21, 26]:
                try:
                    atomNr = int(line[i:i+5].strip())
                except Exception:
                    continue
                bondAtom = self.findAtomNumber(atomNr)
                if bondAtom:
                    bondAtoms.append(bondAtom)

            for i in [31, 36, 46, 51]:
                try:
                    atomNr = int(line[i:i+5].strip())
                except Exception:
                    continue
                bondAtom = self.findAtomNumber(atomNr)
                if bondAtom:
                    hydrogenBondedAtoms.append(bondAtom)

            for i in [41, 56]:
                try:
                    atomNr = int(line[i:i+5].strip())
                except Exception:
                    continue
                bondAtom = self.findAtomNumber(atomNr)
                if bondAtom:
                    saltBridgedAtoms.append(bondAtom)

            if atom:
                molecule = atom.residue.molecule
                findBond = molecule.findBond
                for dest in bondAtoms:
                    bond = findBond(atom, dest)
                    if not bond:
                        bond = Bond(atom, dest)
                        molecule.bonds.add(bond)
                        atom.bonds.add(bond)
                        dest.bonds.add(bond)
                    elif bond.fromAtom == atom:
                        bond.order += 1

                for dest in hydrogenBondedAtoms:
                    bond = findBond(atom, dest, bondType = 'hydrogenBond')
                    if not bond:
                        bond = Bond(atom, dest, bondType = 'hydrogenBond')
                        molecule.bonds.add(bond)

                for dest in saltBridgedAtoms:
                    bond = findBond(atom, dest, bondType = 'saltBridge')
                    if not bond:
                        bond = Bond(atom, dest, bondType = 'saltBridge')
                        molecule.bonds.add(bond)

    def readMol2Atoms(self, mole, lines, startLineNr):

        nLines = len(lines)

        for i in range(startLineNr, nLines):
            if lines[i].startswith('@<TRIPOS>ATOM'):
                break
            elif lines[i].startswith('@'):
                return i
        else:
            return

        for i in range(i+1, nLines):
            line = lines[i]

            if line.startswith('@'):
                return i

            parts = line.split()

            nParts = len(parts)
            if nParts < 6:
                continue

            atomNr = int(parts[0])
            atomName = parts[1]
            atomX = float(parts[2])
            atomY = float(parts[3])
            atomZ = float(parts[4])
            atomType = parts[5]
            element = atomType.split('.')[0]

            if nParts == 6:
                continue

            resNr = int(parts[6]) + self.residueOffset

            if nParts >= 8:
                resName = parts[7]
                if nParts >= 9:
                    charge = float(parts[8])
                    if nParts >= 10:
                        statusBit = parts[9]
                    else:
                        statusBit = None
                else:
                    charge = None
            else:
                resName = None

            res = mole.findResidue(resName, resNr)
            if not res:
                res = Residue(resName, mole, resNr)
                mole.residues.append(res)

            atom = Atom(res, atomNr, atomName, element)

            atom.setAtomClass('HETATM')
            atom.setCharge(charge)
            atom.setCoords(atomX, atomY, atomZ)
            atom.setAtomType(atomType)
            atom.setStatusBit(statusBit)

            res.atoms.append(atom)
            mole.atoms.append(atom)

        return i

    def readMol2Bonds(self, mole, lines, startLineNr):

        nLines = len(lines)

        for i in range(startLineNr, nLines):
            if lines[i].startswith('@<TRIPOS>BOND'):
                break
            elif lines[i].startswith('@'):
                return i
        else:
            return

        for i in range(i+1, nLines):
            line = lines[i]

            if line.startswith('@'):
                return i

            parts = line.split()

            nParts = len(parts)
            if nParts < 4:
                continue

            fromAtomNr = int(parts[1])
            toAtomNr = int(parts[2])
            bType = parts[3]
            if bType.isdigit():
                bType = int(bType)

            if nParts > 4:
                statusBit = parts[4]
            else:
                statusBit = None

            fromAtom = self.findAtomNumber(fromAtomNr)
            toAtom = self.findAtomNumber(toAtomNr)

            if fromAtom and toAtom:
                if bType == 'ar':
                    fromAtom.setAromatic(True)
                    toAtom.setAromatic(True)

                bond = mole.findBond(fromAtom, toAtom)
                if not bond:
                    bond = Bond(fromAtom, toAtom)
                    if isinstance(bType, int):
                        bond.setOrder(bType)
                    else:
                        bond.setOrder(1)
                        bond.setBondType(bType)

                    bond.setStatusBit(statusBit)

                    mole.bonds.add(bond)
                    fromAtom.bonds.add(bond)
                    toAtom.bonds.add(bond)

        return i

    def addAmsolChargesToAtoms(self, lines, chargeModel):
        # Read the file from the back until the last set of charges using
        # the relevant charge model is found.
        i=len(lines) - 1
        while i:
            line=lines[i]
            if line.find("calculated with %s" % chargeModel)!=-1:
                i+=3
                line=lines[i]
                while len(line)>5 and i<len(lines):
                    parts=line.split()
                    try:
                        nr=int(parts[0])
                        charge=float(parts[2])
                    except Exception:
                        continue
                    atom=self.findAtomNumber(nr)
                    if atom:
                        #print("Setting charge to %f" % charge)
                        atom.charge=charge
                    i+=1
                    line=lines[i]
                break
            i-=1

    def multiplyCharges(self, multiplier):

        for molecule in self.molecules:
            for atom in molecule.atoms:
                atom.charge *= multiplier

    def findAtomNumber(self, number):

        for molecule in self.molecules:
            for atom in molecule.atoms:
                if atom.number == number:
                    return atom
        return None

    def renumberAtoms(self):

        i = 1
        for molecule in self.molecules:
            for atom in molecule.atoms:
                atom.number = i
                i += 1

    def renumberResidues(self):

        i = 1
        for molecule in self.molecules:
            for residue in molecule.residues:
                residue.number = i
                i += 1

    def getCenterCoordinates(self):

        coordX = 0
        coordY = 0
        coordZ = 0
        coord = [coordX, coordY, coordZ]

        n = 0
        for molecule in self.molecules:
            n += len(molecule.atoms)
            for atom in molecule.atoms:
                coordX += atom.coordX
                coordY += atom.coordY
                coordZ += atom.coordZ


        coord[0] = coordX/n
        coord[1] = coordY/n
        coord[2] = coordZ/n

        return coord

    def getClosestAtom(self, coord, noHydrogens = False):

        minDist = None
        minAtom = None

        for molecule in self.molecules:
            for atom in molecule.atoms:
                if noHydrogens and atom.name[0] == 'H':
                    continue
                dist = atom.getDistanceToCoordinate(coord)
                if minDist == None or dist < minDist:
                    minDist = dist
                    minAtom = atom

        return minAtom

    def findHydrogens(self):

        hydrogens = []
        for molecule in self.molecules:
            for atom in molecule.atoms:
                if atom.name[0] == 'H':
                    hydrogens.append(atom)

        return hydrogens

    def getCharge(self):

        charge = 0
        for molecule in self.molecules:
            charge += molecule.getCharge()
        return charge

    def removeRemoteResidues(self, centerAtom, radius):

        i = 0
        j = 0
        for molecule in self.molecules:
            residues = molecule.residues[:]
            for residue in residues:
                keep = False
                atoms = residue.atoms[:]
                for atom in atoms:
                    if atom.getDistanceToAtom(centerAtom) < radius * 2:
                        keep = True
                        break
                if keep == False:
                    for atom in residue.atoms:
                        molecule.atoms.remove(atom)
                    molecule.residues.remove(residue)
                    i += 1
#                    print('%d atoms left. %d residues left.'
                            #% (len(self.atoms), len(self.residues)))
                else:
                    j += 1
                residue.atoms = atoms
            molecule.residues = residues

    def findResidues(self, name):

        residues = []
        for molecule in self.molecules:
            for residue in molecule.residues:
                if residue.name == name:
                    residues.append(residue)
        return residues

    def renameAtoms(self):

        for molecule in self.molecules:
            molecule.renameAtoms()

class Molecule:

    def __init__(self, name, molSystem, residues = None, atoms = None):

        self.name = name
        self.molSystem = molSystem
        self.residues = residues or []
        self.atoms = atoms or []
        self.bonds = set()
        self.molType = 'SMALL'
        self.chargeType = 'GASTEIGER'
#        print('Chain name ' + name)

    def getAtoms(self):

        return self.atoms

    def getResidues(self):

        return self.residues

    def writeMol2(self, outFile):

        outFile.write('@<TRIPOS>MOLECULE\n')
        if self.name:
            outFile.write('%s\n' % self.name)
        else:
            outFile.write('*****\n')
        outFile.write('%d %d 0 0 0\n' % (len(self.atoms), len(self.bonds)))
        outFile.write('%s\n' % self.molType)
        outFile.write('%s\n\n' % self.chargeType)
        if self.atoms:
            outFile.write('@<TRIPOS>ATOM\n')

            atoms = sorted(self.atoms, key = lambda a: a.number)
            for a in atoms:
                outFile.write('%s\n' % a.mol2Output())

            if self.bonds:

                outFile.write('@<TRIPOS>BOND\n')

                bonds = sorted(self.bonds,
                               key = lambda b: (b.fromAtom.number, b.toAtom.number))
                for i, b in enumerate(bonds):
                    outFile.write('%6d %s\n' % (i+1, b.mol2Output()))

        outFile.write('\n\n')

    def findResidue(self, name = None, number = None):

        if name == None and number == None:
            return None

        for residue in self.residues:
            if (name == None or residue.name == name) and \
               (number == None or residue.number == number):
                return residue
        return None

    def findResidues(self, name):

        residues = []
        for residue in self.residues:
            if residue.name == name:
                residues.append(residue)
        return residues

    def countResidues(self, name = None):

        if name:
            cnt = 0
            for residue in self.residues:
                if residue.name == name:
                    cnt = cnt+1
        else:
            cnt = len(self.residues)

        return cnt

    def findAtom(self, name):

        for atom in self.atoms:
            if atom.name == name:
                return atom
        return None

    def findAtoms(self, name):

        atoms = []
        for atom in self.atoms:
            if atom.name == name:
                atoms.append(atom)
        return atoms

    def getCharge(self):

        charge = 0
        for atom in self.atoms:
            charge += atom.getCharge()
        return charge

    def getName(self):

        return self.name

    def getCenterCoordinates(self):

        coordX = 0
        coordY = 0
        coordZ = 0
        coord = [coordX, coordY, coordZ]

        n = len(self.atoms)
        for atom in self.atoms:
            coordX += atom.coordX
            coordY += atom.coordY
            coordZ += atom.coordZ

        coord[0] = coordX/n
        coord[1] = coordY/n
        coord[2] = coordZ/n

        return coord

    def getCenterCoordinatesOfAtoms(self, atoms):

        coordX = 0
        coordY = 0
        coordZ = 0
        coord = [coordX, coordY, coordZ]

        n = len(atoms)
        for atom in atoms:
            coordX += atom.coordX
            coordY += atom.coordY
            coordZ += atom.coordZ

        coord[0] = coordX/n
        coord[1] = coordY/n
        coord[2] = coordZ/n

        return coord

    def getCenterOfMass(self):

        coordX = 0
        coordY = 0
        coordZ = 0
        coord = [coordX, coordY, coordZ]
        totMass = 0

        for atom in self.atoms:
            if atom.mass == None:
                if atom.element:
                    atomElement = atom.element
                elif atom.atomType:
                    atomElement = atom.atomType.split('.')[0]
                if atomElement in ATOMMASSES:
                    atom.mass = ATOMMASSES[atomElement]
                else:
                    if atom.atomType:
                        atomType = atom.atomType
                    else:
                        atomType = atom.name[:2].title()
                    atomType = atomType.title()
                    if atomType in ATOMMASSES:
                        atom.mass = ATOMMASSES[atomType]
                    elif atomType[0] in ATOMMASSES:
                        atom.mass = ATOMMASSES[atomType[0]]
                    else:
                        print('Cannot find mass of atom', atom.name)
                        print('Center of mass might not be accurate.')
                        continue


            coordX += atom.coordX * atom.mass
            coordY += atom.coordY * atom.mass
            coordZ += atom.coordZ * atom.mass
            totMass += atom.mass
            #print atom.name, atom.coordX, atom.coordY, atom.coordZ, coordX, coordY, coordZ, totMass

        coord[0] = coordX/totMass
        coord[1] = coordY/totMass
        coord[2] = coordZ/totMass

        return np.array(coord)

    def getTotalMass(self):

        mass = 0
        for atom in self.atoms:
            if atom.mass == None:
                if atom.element:
                    atomElement = atom.element
                elif atom.atomType:
                    atomElement = atom.atomType.split('.')[0]
                if atomElement in ATOMMASSES:
                    atom.mass = ATOMMASSES[atomElement]
                else:
                    if atom.atomType:
                        atomType = atom.atomType
                    else:
                        atomType = atom.name[:2].title()
                    atomType = atomType.title()
                    if atomType in ATOMMASSES:
                        atom.mass = ATOMMASSES[atomType]
                    elif atomType[0] in ATOMMASSES:
                        atom.mass = ATOMMASSES[atomType[0]]
                    else:
                        print('Cannot find mass of atom', atom.name)
                        print('Total mass might not be accurate.')
                        continue


            mass += atom.mass

        return mass

    def getMomentOfInertia(self, centerOfMass = None):

        if centerOfMass == None:
            centerOfMass = self.getCenterOfMass()
            #print 'center of mass:', centerOfMass
        momentOfInertia = 0
        for atom in self.atoms:
            #print 'atom mass:', atom.mass, 'atom pos:', atom.getCoords(), 'distance to center:', atom.getDistanceToCoordinate(centerOfMass)
            momentOfInertia += atom.mass * pow(atom.getDistanceToCoordinate(centerOfMass), 2)

        return momentOfInertia

    def getDipole(self, centerCoords = None):
        """ Calculates the dipole vector (and returns it in D) """

        if not numpyFound:
            print('Numpy required for dipole moment calculations.')
            return None

        if centerCoords == None:
            centerCoords = self.getCenterOfMass()
            if not centerCoords.all():
                centerCoords = self.getCenterCoordinates()

        centerCoords = np.array(centerCoords)

        #print 'Center:', centerCoords

        dipoleSum = np.array([0, 0, 0], dtype=float )
        dipole = np.array([0, 0, 0])
        for atom in self.atoms:
            dipole = [atom.coordX, atom.coordY, atom.coordZ] - centerCoords
            #print dipole, atom.charge
            dipole *= 1.60217657e-19 * atom.charge * 1e-10
            dipoleSum += dipole

        return dipoleSum/(1e-21/299792458)

    def containsElement(self, element):

        for atom in self.atoms:
            if atom.isElement(element):
                return True
        return False

    def findBond(self, fromAtom, toAtom, order = None, bondType = None):

        for bond in self.bonds:
            if (bond.fromAtom is fromAtom and bond.toAtom is toAtom) or \
               (bond.fromAtom is toAtom and bond.toAtom is fromAtom):
                if order != None and order != bond.order:
                    continue
                if bondType != None and bondType != bond.bondType:
                    continue
                return bond


# getDihedral is based on the atoms class in ASE (LGPL)
# Copyright 2008, 2009 CAMd
# Copyright 2012 Magnus Lundborg
# (see accompanying license files for details).

    def getDihedral(self, atoms):
        if not numpyFound:
            print('getDihedral requires numpy')
            return None
        """Calculate dihedral angle.

        Calculate dihedral angle between a list of four atoms.
        """

        # vector 0->1, 1->2, 2->3 and their normalized cross products:

        if len(atoms) != 4:
            raise IndexError('Four atoms required in dihedral')

        a = atoms[1].getCoords() - atoms[0].getCoords()
        b = atoms[2].getCoords() - atoms[1].getCoords()
        c = atoms[3].getCoords() - atoms[2].getCoords()
        bxa = np.cross(b, a)
        bxa /= np.linalg.norm(bxa)
        cxb = np.cross(c, b)
        cxb /= np.linalg.norm(cxb)
        angle = np.vdot(bxa, cxb)
        # check for numerical trouble due to finite precision:
        if angle < -1:
            angle = -1
        if angle > 1:
            angle = 1
        angle = np.arccos(angle)
        if np.vdot(bxa, c) > 0:
            angle = 2 * np.pi - angle
        return angle


    def renameAtoms(self):

        for residue in self.residues:
            residue.renameAtoms()

    def assignChargeGroups(self):

        for residue in self.residues:
            residue.assignChargeGroups()


class Residue:

    def __init__(self, name, molecule, number = 1, atoms = None, bonds = None,
                             chargeGroups = None, chain = 'A'):

        self.name = name
        self.molecule = molecule
        self.number = number
        self.atoms = atoms or []
        self.bonds = bonds or []
        self.chargeGroups = chargeGroups or []
        self.chain = chain or []

    def getName(self):

        return self.name

    def setName(self, name):

        self.name = name

    def getNumber(self):

        return self.number

    def setNumber(self, number):

        self.number = number

    def getMolecule(self):

        return self.molecule

    def findAtom(self, name):

        for atom in self.atoms:
            if atom.name == name:
                return atom
        return None

    def findAtoms(self, name):

        atoms = []
        for atom in self.atoms:
            if atom.name == name:
                atoms.append(atom)
        return atoms

    def findAtomsOfType(self, atomType):

        atoms = []
        for atom in self.atoms:
            if atom.atomType == atomType:
                atoms.append(atom)
        return atoms

    def countAtoms(self, name = None):

        if name:
            cnt = 0
            for atom in self.atoms:
#                print('Wanted name: %s Atom name: %s' % (name, a.name))
                if atom.name == name:
                    cnt = cnt + 1
#                    print(cnt)
        else:
            cnt = len(self.atoms)
        return cnt

    def findBond(self, fromAtom, toAtom):

        for bond in self.bonds:
            if bond.toAtom == toAtom and bond.fromAtom == fromAtom:
                return bond
        return None

    def findAllBonds(self, atom):

        foundBonds = []
        for bond in self.bonds:
            if bond.toAtom == atom or bond.fromAtom == atom:
                foundBonds.append(bond)
        return foundBonds

    def findChargeGroup(self, atoms):

        found = True
        for chargeGroup in self.chargeGroups:
            if len(atoms) == len(chargeGroup.atoms):
                for i in range(len(atoms)):
                    if(atoms[i].name != chargeGroup.atoms[i].name):
                        found = False
                        break
                if found:
                    return chargeGroup

        return None

    def renumberAtoms(self):

        i = 1
        for atom in self.atoms:
            atom.number = i
            i += 1

    def mergeChargeGroups(self, groupA, groupB):

        if groupA.residue != self or groupB.residue != self:
            print('Cannot merge charge groups from different residues')
            return None
        for atom in groupB.atoms:
            groupA.atoms.append(atom)

        self.chargeGroups.remove(groupB)
        groupB.residue = None

        return groupA

    def assignChargeGroups(self):

        self.chargeGroups = []
        doneAtoms = set()
        for atom in self.atoms:
            element = atom.getElement()
            if element != 'C' or atom in doneAtoms:
                continue

            groupAtoms = [atom]
            doneAtoms.add(atom)
            groupCharge = atom.getCharge()
            hydrogens = atom.getNeighbours(element = 'H')
            for hydrogen in hydrogens:
                groupAtoms.append(hydrogen)
                doneAtoms.add(hydrogen)
                groupCharge += hydrogen.getCharge()
            if abs(groupCharge) <= 0.001:
                continue

            neighbours = atom.getNeighbours()
            for neighbour in neighbours:
                if neighbour.getElement() == 'C' or neighbour in doneAtoms:
                    continue
                groupAtoms.append(neighbour)
                groupCharge += neighbour.getCharge()
                doneAtoms.add(neighbour)
                hydrogens = neighbour.neighbours(element = 'H')
                for hydrogen in hydrogens:
                    groupAtoms.append(hydrogen)
                    groupCharge += hydrogen.getCharge()
                    doneAtoms.add(neighbour)

            if abs(groupCharge) > 0.001:
                for groupAtom in groupAtoms:
                    doneAtoms.remove(atom)
                groupAtoms = [atom]

            chargeGroup = ChargeGroup(self, groupAtoms)
            self.chargeGroups.append(chargeGroup)

        for atom in self.atoms:
            if atom.getChargeGroup() == None:
                chargeGroup = ChargeGroup(self, [atom])
                self.chargeGroups.append(chargeGroup)

    def getCharge(self):

        charge = 0
        for atom in self.atoms:
            charge += atom.getCharge()
        return charge

    def renameAtoms(self):

        for atom in self.atoms:
            element = atom.getElement()
            if not element:
                atom.element = ''.join([a for a in atom.name if a.isalpha()])
                element = atom.element
            if atom.element == 'C':
                atom.name = 'C%d' % atom.number
            else:
                atom.name = None

        # C is already done - H should be done after the heavy atoms
        for i in range(2):
            for atom in [a for a in self.atoms if a.getElement() != 'C']:
                if i == 0 and atom.getElement() == 'H':
                    continue
                elif i!=0 and atom.getElement() != 'H':
                    continue

                neighbours = atom.getNeighbours()
                if not neighbours:
                    atom.name = '%s%d' % (atom.getElement(), atom.number)
                    continue

                for neighbour in neighbours:
                    if neighbour.name:
                        break
                else:
                    atom.name = '%s%s%d' % (atom.getElement(),
                                neighbour.getElement(), neighbour.number)
                    # Check that the name is unique
                    cnt = self.countAtoms(atom.name)
                    if cnt > 1:
                        atom.name += '%d' % cnt
                    continue

                nextNeighbours = neighbour.getNeighbours(atom)
                cnt = 1
                index = 1
                for nN in nextNeighbours:
                    if nN.element == atom.getElement():
                        cnt += 1
                        if nN.number < atom.number:
                            index += 1

                atom.name = '%s%s' % (atom.getElement(), neighbour.getElement())
                # Append the neighbour's number
                num = ''.join([a for a in neighbour.name if a.isdigit()])
                if num:
                    atom.name += num
                # If no numbered neighbour was found look for next neighbours
                else:
                    for nN in nextNeighbours:
                        num = ''.join([a for a in nN.name if a.isdigit()])
                        if num:
                            atom.name += num
                            break
                    else:
                        atom.name += '%d' % atom.number

                if cnt > 1:
                    atom.name += '%d' % index

                # Check that the name is unique
                cnt = self.countAtoms(atom.name)
                if cnt > 1:
                    atom.name += '%d' % cnt

        # The length of the name must not be longer than 4 characters.
        for atom in self.atoms:
            if len(atom.name) > 4:
                if atom.name[:2].isalpha():
                    alphaName = atom.name[:2]
                else:
                    alphaName = atom.name[0]
                for i in range (1,99):
                    tempName = '%s%d' % (alphaName, i)
                    if not self.findAtom(tempName):
                        atom.name = tempName
                        break

                else:
                    alphaName = atom.name[0]
                    for i in range(1,999):
                        tempName = '%s%d' % (alphaName, i)
                        if not self.findAtom(tempName):
                            atom.name = tempName
                            break

# Class for atoms
class Atom:
    def __init__(self, residue, number, name, element = None):

        self.residue = residue
        self.number = number
        self.name = name
        self.atomType = None
        if element:
            self.element = element
        else:
            delchars = ''.join(c for c in map(chr, range(256)) if not
                               c.isalpha())
            self.element = self.name.translate(None, delchars)

        if self.element in ATOMMASSES:
            self.mass = ATOMMASSES[self.element]
        else:
            self.mass = None
        self.charge = None
        self.formalCharge = None
        self.aromatic = None
        self.coordX = 0.0
        self.coordY = 0.0
        self.coordZ = 0.0
        self.velX = 0.0
        self.velY = 0.0
        self.velZ = 0.0
        self.occupancy = 1.00
        self.atomClass = 'ATOM'
        self.tempFactor = 0.00
        self.segment = 'P'
        self.alternateLocation = ''
        self.insertCode = ''
        self.statusBit = None
        self.bonds = set()

    def pdbOutput(self):

        string = '%-6s%5d' % (self.atomClass, self.number)
        if len(self.name) == 4:
            string += ' %s' % self.name
        else:
            string += '  %-3s' % self.name

        string += '%1s%-3s %1s%4d%1s' % (self.alternateLocation,
                                         self.residue.name, self.residue.chain,
                                         self.residue.number,
                                         self.insertCode)
        string += '   %8.3f%8.3f%8.3f' % (self.coordX, self.coordY,
                                          self.coordZ)
        string += ' %5.2f %5.2f      %-4s%-2s' % (self.occupancy,
                                                 self.tempFactor,
                                                 self.segment,
                                                 self.element)
        if self.formalCharge:
            string += '%d' % int(self.formalCharge)

        return string

    def mol2Output(self):

        if not self.atomType:
            self.atomType = self.element

        string = '%7s %-10s %9.4f %9.4f %9.4f %-7s %2d %-8s %9.4f' % (self.number,
                 self.name, self.coordX, self.coordY, self.coordZ,
                 self.atomType, self.residue.number, self.residue.name,
                 self.charge)

        return string

    def groOutput(self):

        string = '%5d%-5s%5s%5d%8.3f%8.3f%8.3f' % (self.residue.number,
                                                   self.residue.name,
                                                   self.name,
                                                   self.number,
                                                   self.coordX / 10,
                                                   self.coordY / 10,
                                                   self.coordZ / 10)

        if self.velX != None and self.velY != None and self.velZ != None:
            string += '%8.4f%8.4f%8.4f' % (self. velX / 10, self.velY / 10, self.velZ / 10)

        return string

    def pdbBondOutput(self):

        string = 'CONECT%5d' % self.number
        for n in self.getNeighbours():
            string += '%5d' % n.number

        return string

    def amsolOutput(self):
        optimize="1"
        delchars = ''.join(c for c in map(chr, range(256)) if not c.isalpha())
        element=self.element
        #if element[0]=="H":
            #element="H"
        str="%-6s%8.3f %s %8.3f %s %8.3f %s" % (element, self.coordX, optimize, self.coordY, optimize, self.coordZ, optimize)
        return str

    def getAtomClass(self):

        return self.atomClass

    def setAtomClass(self, atomClass):

        self.atomClass = atomClass

    def getAtomType(self):

        return self.atomType

    def setAtomType(self, tp):

        self.atomType = tp
        if not self.mass:
            atomType = tp
            if atomType:
                atomType = atomType.title()
                if atomType in ATOMMASSES:
                    self.mass = ATOMMASSES[atomType]
                elif atomType[0] in ATOMMASSES:
                    self.mass = ATOMMASSES[atomType[0]]

    def getCharge(self):

        return self.charge

    def setCharge(self, charge):

        self.charge = charge

    def getFormalCharge(self):

        return self.formalCharge

    def setFormalCharge(self, charge):

        self.formalCharge = charge

    def getMass(self):

        return self.mass

    def setMass(self, mass):

        self.mass = mass

    def getAromatic(self):

        return self.aromatic

    def setAromatic(self, isAromatic):

        self.aromatic = isAromatic

    def getCoords(self):

        if not numpyFound:
            print('getCoords requires numpy.')
            return None
        return np.array([self.coordX, self.coordY, self.coordZ])

    def setCoords(self, x, y, z):

        self.coordX = x
        self.coordY = y
        self.coordZ = z

    def getVels(self):

        if not numpyFound:
            print('getVels requires numpy.')
            return None
        return np.array([self.velX, self.velY, self.velZ])

    def setVels(self, x, y, z):

        self.velX = x
        self.velY = y
        self.velZ = z

    def getOccupancy(self):

        return self.occupancy

    def setOccupancy(self, occupancy):

        self.occupancy = occupancy

    def getTempFactor(self):

        return self.tempFactor

    def setTempFactor(self, factor):

        self.tempFactor = factor

    def getSegment(self):

        return self.segment

    def setSegment(self, segment):

        self.segment = segment

    def getAlternateLocation(self):

        return self.alternateLocation

    def setAlternateLocation(self, altLoc):

        self.alternateLocation = altLoc

    def getInsertCode(self):

        return self.insertCode

    def setInsertCode(self, code):

        self.insertCode = code

    def getStatusBit(self):

        return self.statusBit

    def setStatusBit(self, bit):

        self.statusBit = bit

    def getResidue(self):

        return self.residue

    def getMolecule(self):

        if self.residue:
            molecule = self.residue.getMolecule()
            return molecule

    def getElement(self):

        if self.element:
            return self.element

        element = atom.atomType.split('.')[0]
        if element in ATOMMASSES:
            return element
        else:
            element = atom.atomType
            element = element.title()

        if element in ATOMMASSES:
            return element

        return None

    def isElement(self, element):

        if self.getElement() == element:
            return True
        return False

    def getDistanceToCoordinate(self, coord):

        distX = self.coordX - coord[0]
        distY = self.coordY - coord[1]
        distZ = self.coordZ - coord[2]

        dist = math.sqrt(math.pow(distX, 2)+math.pow(distY, 2)+
                         math.pow(distZ, 2))

        return dist

    def getDistanceToAtom(self, atom):

        distX = self.coordX-atom.coordX
        distY = self.coordY-atom.coordY
        distZ = self.coordZ-atom.coordZ

        dist = math.sqrt(math.pow(distX, 2)+math.pow(distY, 2)+
                         math.pow(distZ, 2))

        return dist

    def getDistanceMatrixToAtom(self, atom):

        distX = atom.coordX-self.coordX
        distY = atom.coordY-self.coordY
        distZ = atom.coordZ-self.coordZ

        return np.array([distX, distY, distZ])

    def getClosestAtom(self, onlyInSameMolecule = True):

        closest = None
        closestDist = None

        if onlyInSameMolecule:
            atoms = self.residue.molecule.atoms
        else:
            atoms = []
            for molecule in self.residue.molecule.molSystem.molecules:
                atoms.extend(molecule.atoms)
        for atom in atoms:
            if atom is self:
                continue
            dist = self.getDistanceToAtom(atom)
            if not closest or dist < closestDist:
                closest = atom
                closestDist = dist

        return closest

    def getAtomsWithinDistance(self, minDist, maxDist, onlyInSameMolecule = True):

        foundAtoms = set()

        if onlyInSameMolecule:
            atoms = self.residue.molecule.atoms
        else:
            atoms = []
            for molecule in self.residue.molecule.molSystem.molecules:
                atoms.extend(molecule.atoms)
        for atom in atoms:
            if atom is self:
                continue
            dist = self.getDistanceToAtom(atom)
            if minDist <= dist <= maxDist:
                foundAtoms.add(atom)

        return foundAtoms

    def getNeighbours(self, prevAtom = None, element = None):

        neighbours = []
        for bond in self.bonds:
            if prevAtom and (bond.fromAtom is prevAtom or
                             bond.toAtom is prevAtom):
                continue
            if bond.fromAtom == self:
                if element and bond.toAtom != element:
                    continue
                neighbours.append(bond.toAtom)
            else:
                if element and bond.fromAtom != element:
                    continue
                neighbours.append(bond.fromAtom)

        return sorted(neighbours, key = lambda a: (-a.mass, a.number))


    def getChargeGroup(self):

        for chargeGroup in self.residue.chargeGroups:
            groupAtoms = chargeGroup.getAtoms()
            if self in groupAtoms:
                return chargeGroup

    # getRings is based on VarAtom.getRings from CcpNmr ChemBuild (LGPL).
    # Copyright Tim Stevens and Magnus Lundborg,
    # University of Cambridge 2010-2012
    def getRings(self):

        stack = []
        rings = set()

        neighbours = self.getNeighbours()

        for neighbour in neighbours:
            if neighbour.element != 'H':
                stack.append( [self, neighbour] )

        while stack:

            prev = stack.pop()
            if len(prev) > 8:
                continue

            prevSet = set(prev)

            nextAtoms = set([atom for atom in prev[-1].getNeighbours() if
                            atom.element != 'H'])
            if prev[-2] in nextAtoms:
                nextAtoms.remove(prev[-2])

            for atom in nextAtoms:
                if atom is self:
                    rings.add( frozenset(prev) )

                elif atom not in prevSet:
                    nextSet = prev[:] + [atom,]
                    stack.append(nextSet)

        filteredRings = set()

        if rings:
            rings = sorted(rings, key=lambda ring: len(ring))
            minSz = len(rings[0])
            minRing = rings[0]
            filteredRings.add(minRing)

            uniqueAtoms = set()
            for ring in rings[1:]:
                unique = ring
                for ring2 in filteredRings:
                    unique = unique - ring2
                    nUnique = len(unique)
                    if nUnique > 0 and unique not in uniqueAtoms:
                        for ua in unique:
                            if ua in neighbours:
                                break
                        else:
                            continue
                        uniqueAtoms.add(unique)
                        filteredRings.add(ring)

        return filteredRings

    def getRingSizes(self):

        sizes = []

        for ring in self.getRings():
            sizes.append(len(ring))

        return sizes

    def genEmptyPropertiesCode(self, depth):

        nCode = []
        nCode.append(None)
        for j in range(3):
            nCode.append(0)
        nCode.append(None)

        for i in range(depth):
            for k in range(4):
                nCode.append(self.genEmptyPropertiesCode(depth-1))

        return nCode

    # 0: element (char)
    # 1: formal charge (int)
    # 2: size of smallest ring (int)
    # 3: size of second smallest ring (int)
    # 4: aromatic (True/False. None if not known)
    # 5: properties codes of neighbours
    def getPropertiesCode(self, depth = None, prevAtom = None, nonBondedDistances = 0):

        code = []
        neighbours = []
        nonBonded = []

        code.append(self.element)
        # Assume 0 formal charge if not specified
        code.append(int(self.formalCharge or 0))
        ringSizes = self.getRingSizes()
        nRings = len(ringSizes)
        # Two smallest ring sizes
        for i in range(2):
            if i < len(ringSizes):
                code.append(ringSizes[i])
            else:
                code.append(0)
        code.append(self.aromatic)

        if depth:
            neighbours = self.getNeighbours(prevAtom)
            nNeighbours = len(neighbours)
            # 4 neighbour fields in the code
            for i in range(4):
                if i < nNeighbours:
                    neighbour = neighbours[i]
                    nCode = neighbour.getPropertiesCode(depth-1, self, 0)
                else:
                    nCode = self.genEmptyPropertiesCode(depth-1)

                code.append(nCode)

        for dist in range(nonBondedDistances):
            if not neighbours:
                neighbours = self.getNeighbours(prevAtom)

            withinDistance = self.getAtomsWithinDistance(dist-1, dist)
            withinDistance -= set(neighbours)
            nonBonded.append(withinDistance)

        return flatten(code)

class Bond:

    def __init__(self, fromAtom, toAtom, order = 1, bondType = 'covalent'):

        self.fromAtom = fromAtom
        self.toAtom = toAtom
        self.order = order
        self.bondType = bondType
        self.statusBit = None

    def mol2Output(self):

        string = '%5d %5d ' % (self.fromAtom.number, self.toAtom.number)
        if self.bondType in ['am', 'ar']:
            string += '%4s' % self.bondType
        else:
            string += '%4d' % self.order

        return string

    def getFromAtomResidue(self):

        return self.fromAtom.getResidue()

    def getToAtomResidue(self):

        return self.toAtom.getResidue()

    def getOrder(self):

        return self.order

    def setOrder(self, order):

        self.order = order

    def getBondType(self):

        return self.bondType

    def setBondType(self, bType):

        self.bondType = bType

    def getStatusBit(self):

        return self.statusBit

    def setStatusBit(self, bit):

        self.statusBit = bit

class ChargeGroup:

    def __init__(self, residue, atoms):

        self.residue = residue
        self.atoms = atoms
        self.number = len(residue.chargeGroups)

    def charge(self):

        charge = 0.0
        for atom in self.atoms:
            charge = charge + float(atom.charge)
        return charge

    def getAtoms(self):

        return self.atoms
